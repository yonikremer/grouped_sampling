# Generated by CodiumAI

import pytest
import torch

from src.grouped_sampling.top_p import TopPProbabilityProcessor

"""
Code Analysis

Main functionalities:
The TopPProbabilityProccesor class is used to process probabilities by keeping only the top p values and setting the rest to 0. The class keeps the top values for each vector in the last dimension such that their sum is top p or more. This is useful in natural language processing tasks such as language modeling and text generation, where the model needs to generate text that is coherent and grammatically correct.

Methods:
- __init__(self, minimum_tokens_to_keep: int, top_p: float, device: torch.device): Constructor method that initializes the class with the minimum number of tokens to keep, top p value, and device.
- __call__(self, probs: torch.Tensor) -> torch.Tensor: Method that takes in a tensor of probabilities and returns a tensor of processed probabilities with only the top p values kept and the rest set to 0.
- _validate_probs(self, probs): Method that validates the input probabilities tensor to ensure that it has the correct shape and values.

Fields:
- top_p: A float value representing the top p value to keep.
- min_tokens_to_keep: An integer value representing the minimum number of tokens to keep.
- device: A torch.device object representing the device to use for processing.
"""


class TestTopPProbabilityProccesor:
    #  Tests that the class processes probabilities correctly when given valid inputs
    @pytest.mark.parametrize(
        "device",
        [torch.device("cpu"), torch.device("cuda")])
    def test_valid_input_processing(self, device):
        processor = TopPProbabilityProcessor(1, 0.5)
        probs = torch.tensor([[[0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1]]],
                             device=device)
        expected_output = torch.tensor(
            [[[0.0, 0.0, 0.3, 0.4], [0.4, 0.3, 0.0, 0.0]]], device=device)
        assert torch.allclose(processor(probs), expected_output)

    #  Tests that the class keeps the top p values for each vector in the last dimension such that their sum is top p or more
    @staticmethod
    def test_top_p_values_sum_to_top_p_or_more():
        processor = TopPProbabilityProcessor(1, 0.5)
        probs = torch.tensor([[[0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1]]])
        output = processor(probs)
        assert (output.sum(dim=-1) >= processor.top_p).all()

    #  Tests that the class sets the rest of the values to 0
    @staticmethod
    def test_rest_of_values_set_to_0():
        processor = TopPProbabilityProcessor(1, 0.5)
        probs = torch.tensor([[[0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1]]])
        output = processor(probs)
        assert (output
                > 0).sum(dim=-1).min() >= processor.minimum_tokens_to_keep

    #  Tests that the class keeps at least min_tokens_to_keep tokens
    @staticmethod
    def test_keeps_at_least_min_tokens_to_keep():
        processor = TopPProbabilityProcessor(2, 0.5)
        probs = torch.tensor([[[0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1]]])
        output = processor(probs)
        assert (output.sum(dim=-1) >= processor.top_p).all()
        assert (output
                > 0).sum(dim=-1).min() >= processor.minimum_tokens_to_keep

    #  Tests that the class raises a TypeError when top_p is not a float
    @staticmethod
    def test_raises_type_error_when_top_p_not_float():
        with pytest.raises(TypeError):
            TopPProbabilityProcessor(1, "not_a_float")  # type: ignore

    #  Tests that the class raises a ValueError when top_p is less than or equal to 0
    @staticmethod
    def test_raises_value_error_when_top_p_less_than_or_equal_to_0():
        with pytest.raises(ValueError):
            TopPProbabilityProcessor(1, 0)

    #  Tests that the class raises a ValueError when top_p is greater than or equal to 1
    @staticmethod
    def test_raises_value_error_when_top_p_greater_than_or_equal_to_1():
        with pytest.raises(ValueError):
            TopPProbabilityProcessor(1, 1)

    #  Tests that the class raises a ValueError when probs is not a 3 dimensional tensor
    @staticmethod
    def test_raises_value_error_when_probs_not_3_dimensional_tensor():
        processor = TopPProbabilityProcessor(1, 0.5)
        with pytest.raises(ValueError):
            processor(
                torch.tensor([
                    [0.1, 0.2, 0.3, 0.4],
                    [0.4, 0.3, 0.2, 0.1],
                    [0.1, 0.2, 0.3, 0.4],
                    [0.4, 0.3, 0.2, 0.1],
                ]))

    #  Tests that the class raises a ValueError when probs is an empty tensor
    @staticmethod
    def test_raises_value_error_when_probs_empty_tensor():
        processor = TopPProbabilityProcessor(1, 0.5)
        with pytest.raises(ValueError):
            processor(torch.tensor([]))

    #  Tests that the class raises a ValueError when probs contains NaN values
    @staticmethod
    def test_raises_value_error_when_probs_contains_nan_values():
        processor = TopPProbabilityProcessor(1, 0.5)
        with pytest.raises(ValueError):
            processor(
                torch.tensor([[[0.1, 0.2, 0.3, 0.4],
                               [0.4, 0.3, 0.2, float("nan")]]]))

    #  Tests that the class raises a ValueError when probs contains Inf values
    @staticmethod
    def test_raises_value_error_when_probs_contains_inf_values():
        processor = TopPProbabilityProcessor(1, 0.5)
        with pytest.raises(ValueError):
            processor(
                torch.tensor([[[0.1, 0.2, 0.3, 0.4],
                               [0.4, 0.3, 0.2, float("inf")]]]))

    #  Tests that the class raises a ValueError when probs contains negative values
    @staticmethod
    def test_raises_value_error_when_probs_contains_negative_values():
        processor = TopPProbabilityProcessor(1, 0.5)
        with pytest.raises(ValueError):
            processor(
                torch.tensor([[[0.1, 0.2, 0.3, 0.4], [0.4, 0.3, -0.2, 0.1]]]))

    # Tests that the class doesn't use any extra GPU memory
    @staticmethod
    def test_doesnt_use_extra_gpu_memory():
        processor = TopPProbabilityProcessor(1, 0.5)
        probs = torch.tensor([[[0.1, 0.2, 0.3, 0.4], [0.4, 0.3, 0.2, 0.1]]],
                             device="cuda:0")
        with torch.cuda.device(0):
            start_memory = torch.cuda.memory_allocated(0)
            processor(probs)
            assert torch.cuda.memory_allocated(0) == start_memory
